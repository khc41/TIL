## 📅 2025-00-00
### 📚 읽은 개발 서적: [가상면접 사례로 배우는 대규모 시스템 설계 기초](https://product.kyobobook.co.kr/detail/S000001033116)
#### ✏️ 6장 - 키-값 저장소 설계
- 성능상의 이유로 키는 짧을수록 좋다.
#### 문제 이해 및 설계 범위 확정
- 완벽한 설계란 없고, 읽기, 쓰기, 메모리 사용량, 일관성, 가용성 등에서 타협적 결정을 내린 설계를 해야 한다.
- 요구사항
  - 키-값 쌍의 크기는 10KB 이하
  - 큰 데이터를 저장할 수 있어야 함
  - 높은 가용성 제공
  - 높은 규모 확장성 제공, 즉 서버 증설 / 삭제가 자동적으로 이뤄져야 함
  - 데이터 일관성 수준은 조정이 가능해야 함
  - 응답 지연시간이 짧아야 함
#### 단일 서버 키-값 저장소
- 한 대 서버만 사용하는 경우, 가장 직관적인 방법은 전부 메모리에 해시 테이블로 저장하는 것이다.
- 데이터 압축, 자주 쓰이는 데이터 제외 디스크 보관 등의 방법으로 메모리 사용량을 줄일 수 있다.
#### 분산 키-값 저장소
- CAP 정리
  - 데이터 일관성, 가용성, 파티션 감내라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다.
    - 데이터 일관성: 모든 클라이언트는 노드에 관계없이 동일한 데이터를 보게 되어야 한다.
    - 가용성: 일부 노드에 장애가 발생하더라도 항상 응답을 받아야 한다.
    - 파티션 감내: 두 노드 사이에 통신 장애가 발생하더라도 시스템은 동작해야 한다.
  - CP 시스템: 일관성과 파티션 감내를 지원하는 키-값 저장소
  - AP 시스템: 가용성과 파티션 감내를 지원하는 키-값 저장소
  - CA 시스템: 일관성과 가용성을 지원하는 키-값 저장소 (네트워크 장애는 피할 수 없으므로 CA 시스템은 존재하지 않는다.)
  - 노드 n1, n2, n3이 있고 데이터를 복제하여 보관하는 상황에 n3에 장애가 발생한다고 가정했을 때, 
    - 일관성을 선택한다면 (CP 시스템) n1, n2에 대해 쓰기 연산을 중단시켜야 한다.
    - 가용성을 선택한다면 (AP 시스템) n1, n2에 대해 쓰기, 읽기 연산을 허용한다.
  - 요구 사항에 맞도록 CAP 정리를 적용해야 하고 그 결론에 따라 시스템을 설계해야 한다.
- 시스템 컴포넌트
  - 데이터 파티션
    - 데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것
    - 데이터를 고르게 분산해야하고, 노드가 추가되거나 삭제될 때 데이터 이동을 최소화 해야한다.
      - 안정 해시를 사용하면 규모 확장 자동화가 가능하고 각 서버의 용량에 맞게 가상 노드의 수를 조절할 수 있다.
  - 데이터 다중화
    - 높은 가용성과 안정성 확보를 위해 데이터를 N개 서버에 비동기적으로 다중화하는 것
    - 어떤 키를 해시 링 위에 배치한 후, 그 지점으로부터 시계 방향으로 N개의 서버에 저장한다.
    - 같은 물리 서버나 같은 데이터 센터를 중복 선택하지 않아야 한다.
  - 데이터 일관성
    - 다중화된 데이터는 적절히 동기화 되어야 한다.
    - 정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.
      - N = 사본 개수, W = 쓰기 연산에 대한 정족수, R = 읽기 연산에 대한 정족수이고, 각각 적어도 W, R개의 서버로부터 응답을 받아야 한다.
      - R = 1, W = N: 빠른 읽기 연산에 최적화된 시스템
      - W = 1, R = N: 빠른 쓰기 연산에 최적화된 시스템
      - W + R > N: 강한 일관성 보장
      - W + R <= N: 강한 일관성 보장되지 않음
    - 일관성 모델
      - 강한 일관성: 모든 일긱 연산은 가장 최근에 갱신된 결과를 반환한다.
      - 약한 일관성: 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
      - 결과적 일관성: 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영되는 모델이다.
      - 결과적 일관성 모델을 따를 경우 연산이 병렬적으로 발생하면 일관성 문제가 발생할 수 있는데 이 문제는 클라이언트가 해결해야 한다.
    - 비 일관성 해소 기법: 데이터 버저닝
      - 버저닝과 벡터 시계는 일관성 문제를 해결하기 위한 기법이다.
      - 동시에 쓰기 연산이 일어나면 버전간의 충돌이 발생하는데, 벡터 시계는 이런 문제를 푸는 데 보편적으로 사용된다.
      - 벡터 시계
        - 서버, 버전]의 순서쌍을 데이터에 매단 것이다.
        - D3([Sx, 1], [Sy, 1])과 D4([Sx, 2], [Sz, 1])가 있을 때, 클라이언트가 충돌을 해소 후 벡터 시계는 D5([Sx, 3], [Sy, 1], [Sz, 1])이 된다.
        - 클라이언트에 충돌 감지 및 해소 로직이 들어가야해서 복잡해지고, 순서쌍 개수가 굉장히 빨리 늘어난다는 단점이 있다.
    - 장애 감지
      - 두 대 이상의 서버가 똑같이 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주하게 된다.
      - 모든 노드 사이 멀티캐스팅 채널을 구축하는 것이 가장 간단한 방법이지만, 서버가 많을 때 비효율적이다.
      - 가십 프로토콜
        - 각 노드는 맴버십 목록을 유지한다. (맴버 id, heartbeat counter 쌍)
        - 각 노드는 주기적으로 자신의 heartbeat counter를 증가시킨다.
        - 각 노드는 무작위로 선정된 노드들에게 주기적으로 자신의 heartbeat counter 목록을 보낸다.
        - heartbeat counter 목록을 받은 노드는 맴버십 목록을 최신 값으로 갱신한다.
        - 어떤 맴버의 heartbeat counter 값이 지정된 시간동안 갱신되지 않으면 해당 맴버는 장애 상태인 것으로 간주한다.
      - 일시적 장애 처리
        - 장애 서버를 대체해서 쓰기 연산을 처리할 W개의 서버와 읽기 연산을 수행할 R개의 서버를 해시 링에서 고른다.
        - 장애 서버로 가는 요청은 다른 서버가 잠시 처리하고, 그동안 발생한 변경 사항은 복구되었을 때 일괄 반영해 데이터 일관성을 보존한다. 이 방식을 후임시 위탁(hinted handoff)이라고 부른다.
      - 영구 장애 처리
        - 반-엔트로피(anti-entropy) 프로토콜을 구현해 사본들을 동기화한다.
        - 머클 트리
          - 사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해 사용한다.
          - 각 노드에 그 자식 노드들에 보관된 값의 해시(자식 노드가 종단 노드인 경우) 또는, 자식 노드들의 레이블로부터 계산된 해시 값을 레이블로 붙여두는 트리
          - 대규모 자료 구조의 내용을 효과적이면서 보안상 안전한 방법으로 검증 가능하다.
          - 루트 노드의 해시 값이 일치한다면 두 서버는 같은 데이터를 갖는 것이다.
          - 해시 값이 다른 노드들을 비교하다보면 다른 데이터를 갖는 버킷을 찾을 수 있고, 그 버킷들만 동기화하면 된다.
    - 시스템 아키텍처 다이어그램
      - 클라이언트는 읽기, 쓰기 API로 통신한다.
      - 중재자는 키-값 저장소에 대한 프락시 역할을 하는 노드이다.
      - 노드는 안정 해시의 해시 링 위에 분포한다.
      - 노드를 자동을 추가 또는 삭제할 수 있도록 시스템은 완전히 분산된다.
      - 데이터는 여러 노드에 다중화된다.
      - 모든 노드가 같은 책임을 지므로, SPOF는 존재하지 않는다.
    - 쓰기 경로
      - 쓰기 요청이 커밋 로그 파일에 기록된다.
      - 데이터가 메모리 캐시에 기록된다.
      - 메모리 캐시가 가득차거나 임계치에 도달하면 데이터는 디스크에 있는 SSTable(Sorted-String Table)에 기록된다.
    - 읽기 경로
      - 데이터가 메모리 캐시에 있으면 클라이언트에게 반환한다.
      - 없는 경우 디스크에서 가져와야 하는데, 블룸 필터를 통해 어느 SSTable에 있는 지 효율적으로 알아낼 수 있다.

#### 💡 느낀 점
- 카프카를 공부할 때 ISR(in-sync replica)가 데이터 일관성을 보장하기 위해 정족수 합의 알고리즘 비슷한 것을 사용했던 것으로 기억한다. 
- 이는, 대규모 시스템을 처리하기 위해 다른 시스템에도 비슷한 프로토콜이나 알고리즘을 사용한다는 것이라 생각했다.
- 시스템 요구사항에 맞춰서 일관성, 가용성 중 하나를 포기하고 설계해야 한다는 것에서 좋은 설계는 요구사항에 맞춘 설계라고 생각했다.