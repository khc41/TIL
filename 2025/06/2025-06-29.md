## 📅 2025-06-29
### 📚 읽은 개발 서적: [가상면접 사례로 배우는 대규모 시스템 설계 기초](https://product.kyobobook.co.kr/detail/S000001033116)
#### ✏️ 7장 - 분산 시스템을 위한 유일 ID 생성기 설계
- 데이터 베이스의 auto_increment는 여러 데이터베이스 서버를 사용하는 경우 사용하기 힘들다.
#### 1단계 - 문제 이해 및 설계 범위 확정
- 특성, 형태, 시스템 규모들을 적절히 질문해 요구사항을 이해해야 한다.
- 요구사항
  - ID는 유일해야 한다.
  - ID는 숫자로만 구성되어야 한다.
  - ID는 64비트로 표현될 수 있는 값이어야 한다.
  - ID는 발급 날짜에 따라 정렬 가능해야 한다.
  - 초당 10,000개의 ID를 만들 수 있어야 한다.
#### 2단계 - 개략적 설계안 제시 및 동의 구하기
- **다중 마스터 복제**
  - 데이터베이스의 auto_increment 기능을 활용하는데, 데이터 베이스 서버 수인 k만큼 증가시켜 얻는다.
  - 확장성이 부족하고 시간 흐름에 맞추어 커지도록 보장이 불가능하다.
- **UUID**
  - 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수
  - 장점
    - 동기화 이슈가 없다.
    - 규모 확장도 쉽다.
  - 단점
    - 128비트라 길다.
    - 시간순으로 정렬 불가능하다.
    - 숫자가 아닌 값이 포함될 수 있다.
- **티켓 서버**
  - auto_increment 기능을 갖춘 데이터베이스 서버를 중앙 집중형으로 하나만 사용하는 것
  - 장점
    - 유일성이 보장되는 숫자로만 구성된 ID
    - 구현하기 쉽고 중소 규모 애플리케이션에 적합
  - 단점
    - SPOF 위험이 있다.
- **트위터 스노우플레이크 접근법**
  - ID의 구조를 여러 section으로 분할한다. 
    - 사인(sign) 비트: 음수와 양수 구별, 현재는 사용 X
    - 타임스탬프: epoch 이후로 몇 밀리초가 경과했는지 나타내는 값
    - 데이터센터 ID: 5비트를 할당해 32개 데이터센터 지원가능
    - 서버 ID: 5비트를 할당해 데이터센터당 32개의 서버 사용가능
    - 일련번호: 12비트를 할당, 1밀리초가 경과할 때마다 0으로 초기화
#### 3단계 - 상세 설계
- 데이터센터 ID나 서버 ID를 잘못 변경하게 되면 ID 충돌이 발생할 수 있다.
- **타임스탬프**
  - ID는 시간순으로 정렬 가능하게 된다.
  - 41비트라 69년동안만 정상동작 한다.
- **일련번호**
  - 12비트이므로 4096개의 값을 가질 수 있다.
  - 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.
#### 4단계 - 마무리
- 다음 사항을 추가로 논의할 수 있다.
- **시계 동기화**
  - 하나의 서버가 여러 코어에서 실행될 경우 ID 생성 서버들이 같은 시계를 사용하지 않을 수 있다.
  - 이 문제를 해결하기 위해 NTP(Network Time Protocol)를 보편적으로 사용한다.
- **각 절의 길이 최적화**
  - 동시성이 낮고 수명이 긴 애플리케이션이라면, 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적이다.
- **고가용성**
  - ID 생성기는 아주 높은 가용성을 제공해야 한다.

#### 💡 느낀 점
- Snowflake 알고리즘을 강의로 처음 접하게 돼서 요새 많이 사용하고 있다.
- 시간순으로 정렬 가능해 인덱스 성능을 확보하는데 도움이 되고 대규모 트래픽 환경에서도 성능이 좋다는 것만 알고 구조를 몰랐는데 구조를 보니까 어떻게 대규모 트래픽에 대응하는지 알 수 있었다.