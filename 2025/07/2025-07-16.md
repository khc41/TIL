## 📅 2025-07-16
### 📚 읽은 개발 서적: [가상면접 사례로 배우는 대규모 시스템 설계 기초](https://product.kyobobook.co.kr/detail/S000001033116)
#### ✏️ 12장 - 채팅 시스템 설계
#### 1단계 - 문제 이해 및 설계 범위 확정
- 1:1 채팅, 그룹 채팅, 대규모 그룹의 소통과 응답지연이 낮은 음성 채팅인지 질문한다.
- 클라이언트는 어떤 것인지, 트래픽 규모는 어떤지, 그룹 채팅의 경우 인원 제한이 있는지, 첨부파일을 지원하는지, 메시지 길이에 제한이 있는지, 종단 간 암호화를 지원해야 하는지, 채팅 이력의 보관일등을 논의해 요구사항을 확정한다.
- **개략 요구사항**
  - 응답지연이 낮은 일대일 채팅 기능
  - 최대 100명까지 참여가능한 그룹 채팅 기능
  - 사용자 접속상태 표시
  - 다양한 단말 지원
  - 푸시알림
#### 2단계 - 개략적 설계안 제시 및 동의 구하기
- **채팅 서비스 제공 기능**
  - 클라이언트들로부터 메시지 수신
  - 메시지 수신자 결정 및 전달
  - 수신자가 접속 상태가 아니면 접속할 때까지 해당 메시지 보관
- 채팅 서비스의 프로토콜을 면접관과 상의해야 한다.
- **폴링**
  - 클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방법
  - 답해줄 메시지가 없는 경우 서버 자원이 불필요하게 낭비된다.
- **롱 폴링**
  - 클라이언트가 서버에 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다.
  - 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.
  - 메시지 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다.
  - 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 좋은 방법이 없다.
  - 서버 자원이 주기적으로 불필요하게 낭비된다.
- **웹 소켓**
  - 클라이언트가 시작하고, 한번 맺어진 연결은 영구적이며 양방향이다.
  - 80이나 443 처럼 HTTP 혹은 HTTPS 프로토콜이 사용하는 기본 포트번호를 그대로 써서 방화벽이 있는 환경에서도 잘 동작한다.
  - 서버 측에서 연결 관리를 효율적으로 해야한다.
- **개략적 설계안**
  - **무상태 서비스**
    - 로그인, 회원가입, 사용자 프로파일 표시 등을 처리
  - **상태 유지 서비스**
    - 채팅 서비스
    - 서비스 탐색 서비스와 챛팅 서비스와 긴밀히 협력해 특정 서버에 부하가 몰리지 않도록 한다.
  - **제3자 서비스 연동**
    - 푸시알림
  - **규모 확장성**
    - 서버 한 대로 얼마나 많은 접속을 동시에 허용할 수 있는지 확인한다.
    - 동시 접속자가 1M이라고 가정하고, 접속당 10K의 서버 메모리가 필요하면 10GB의 메모리만 있으면 모든 연결을 다 처리할 수 있다.
    - SPOF를 피하기 위해 서버 한대로 처리하지 않는다.
  - **요약**
    - 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할
    - 접속상태 서버는 사용자 접속요부 관리
    - API 서버는 로그인, 회원가입, 프로파일 변경 등 처리
    - 알림 서버는 푸시 알림 전송
    - 키-값 저장소는 채팅이력 보관
  - **저장소**
    - 관계형 데이터베이스를 쓸지 NoSQL을 쓸 지는 데이터의 유형과 읽기/쓰기 연산의 패턴을 보고 결정한다.
    - 사용자 프로파일, 설정, 친구 목록등의 데이터는 관계형 데이터베이스에 보관한다.
    - 채팅 이력 데이터 분석
      - 채팅 이력 데이터의 양은 엄청나다.
      - 최근에 주고받은 메시지를 빈번하게 사용한다.
      - 검색 기능을 이용하거나, 특정 사용자가 언급된 메시지를 보거나, 특정 메시지로 점프하거나 하여 무작위적인 데이터 접근을 지원해야 한다.
      - 1:1 채팅의 경우 읽기:쓰기 비율은 대략 1:1이다.
    - 키-값 저장소에 채팅 이력을 저장한다.
      - 수평적 규모확장이 쉬움
      - 데이터 접근 지연시간이 낮다.
      - 관계형 데이터베이스는 롱 테일에 해당하는 부분을 잘 처리하지 못한다. 인덱스가 커지면 데이터에 대한 무작위적 접근을 처리하는 비용이 커진다.
      - 많은 안정적인 채팅 시스템이 키-값 저장소를 채택하고 있다.
- **데이터 모델**
  - 1:1 채팅을 위한 메시지 테이블
    - 기본키는 message_id로 순서보장
  - 그룹 채팅을 위한 메시지 테이블
    - channel_id와 message_id의 복합키를 기본 키로 사용
    - channel_id는 파티션 키로도 사용
  - 메시지 ID
    - 고유해야하고 정렬 가능해야 한다.
    - 스노우 플레이크나 지역적 순서 번호 생성기를 사용한다.
#### 3단계 - 상세 설계
- **서비스 탐색**
  - 클라이언트의 위치나 서버의 용량을 고려한 클라이언트에게 가장 적합한 채팅 서버를 추천
  - 아파치 주키퍼가 널리 쓰임
  - 로그인하면 서비스 탐색 기능이 동작해 최적의 채팅 서버를 찾고 웹소켓 연결을 맺는다.
- **메시지 흐름**
  - 1:1 채팅 메시지 처리 흐름
    - 채팅 서버로 전송하면 ID 생성기가 메시지 ID를 생성하고 메시지 동기화 큐로 전송한다.
    - 메시지가 키-값 저장소에 보관되고 접속 중인 경우 접속 중인 채팅 서버로 전송되고, 접속중이 아니면 푸시 알림 서버로 전송된다.
  - 여러 단말 사이의 메시지 동기화
    - 단말이 두개인 경우 각 단말은 cur_max_message_id라는 변수를 유지한다. 이 변수는 가장 최신 메시지의 ID를 추적한다.
    - 수신자 ID가 현재 로그인한 사용자 ID와 같고, 키-값 저장소에 보관된 메시지의 ID가 cur_max_message_id보다 크면 새 메시지로 간주한다.
  - 소규모 그룹 채팅에서의 메시지 흐름
    - 사용자 A가 메시지를 보내면 B와 C의 메시지 동기화 큐에 복사된다.
    - 그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업의 비용이 문제되지 않는다.
- **접속상태 표시**
  - **사용자 로그인**
    - 웹소켓 연결이 맺어지면 접속상태 서버는 last_active_at 타임스탬프 값을 키-값 저장소에 보관하고, 해당 사용자는 접속 중인 것으로 표시된다.
  - **로그아웃**
    - 키-값 저장소에 보관된 사용자 상태가 offline으로 바뀐다.
  - **접속 장애**
    - 인터넷 연결이 끊어지면 웹소켓 연결도 끊어지므로, 사용자를 오프라인 상태로 표시하고 연결이 복구되면 온라인 상태로 변경한다.
    - 하지만 연결이 끊어졌다 복구되는 경우는 흔하므로, 너무 자주 변경된다면 사용자 경험 측면에 바람직하지 못하다.
    - heartbeat를 사용해 접속 상태를 확인한다.
      - 클라이언트로 하여금 주기적으로 heartbeat event를 접속상태 서버로 보내고, 마지막 이벤트를 받은 지 x초 이내 메시지를 받지 못하면 오프라인으로 전환한다.
  - **상태 정보의 전송**
    - 상태정보 서버는 각각의 친구관계마다 채널을 하나씩 두는 발행-구독 모델을 사용한다.
    - 그룹 크기가 작을 때 효과적이다.
    - 이를 해결하기 위해 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽거나, 친구 리스트에 있는 사용자의 접속상태를 갱신하고 싶으면 수동으로 하도록 유도한다.
#### 4단계 - 마무리
- 추후 논의사항
  - 사진이나 비디오 등의 미디어를 지원할 때, 압축 방식이나 클라우드 저장소, 썸네일 생성 등을 고려한다.
  - 종단 간 암호화
  - 이미 읽은 메시지를 캐시
  - 사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축해 로딩 속도 개선
  - 채팅 서버 오류나 메시지 재전송 오류 (재시도나 큐)
#### 💡 느낀 점
- 데이터의 유형과 읽기/쓰기 연산 패턴에 따라 데이터베이스를 결정하는 부분이 인상깊었다.
- 사용자 접속상태를 조회하는 부분에서 bloom filter를 사용해 조회할 것이라 생각했는데 별도로 pub-sub 모델을 사용해 상태 정보를 조회하는 부분이 흥미로웠다.
- 채팅 시스템에서 가장 중요한 부분이 프로토콜을 정하고 그에 맞는 설계를 하는 점이라는 것을 배웠다.