## 📅 2025-07-20
### 📚 읽은 개발 서적: [가상면접 사례로 배우는 대규모 시스템 설계 기초](https://product.kyobobook.co.kr/detail/S000001033116)
#### ✏️ 14장 - 유튜브 설계
#### 1단계 - 문제 이해 및 설계 범위 확정
- 댓글, 비디오 공유나 좋아요, 재생목록에 저장, 채널 구독 등을 모두 설계하는 건 불가능하므로 대화를 통해 설계 범위를 좁힌다.
- 가장 중요한 기능, 지원 클라이언트, 일간 능동 사용자 수, 사용자의 평균 소비시간, 다국어 지원 여부, 비디오 해상도, 암호화, 비디오 파일 크기 제한, 클라우드 서비스 활용 여부 등을 질문해서 요구사항을 확정한다.
- **개략 요구사항**
  - 빠른 비디오 업로드
  - 원활한 비디오 재생
  - 재생 품질 선택 기능
  - 낮은 인프라 비용
  - 높은 가용성과 규모 확장성, 안정성
  - 모바일 앱, 웹브라우저, 스마트 TV 지원
- **개략적 규모 추정**
  - 일간 능동 사용자 500만
  - 한 사용자는 하루에 평균 5개 비디오 시청
  - 10% 사용자가 하루에 1개 비디오 업로드
  - 비디오 평균 크기 300MB
  - 비디오 저장을 위해 새로 요구되는 저장용량 = 500만 * 10% * 300MB = 150TB
  - CDN 비용
    - AWS CloudFront를 사용한다고 가정하면 1GB당 $0.02
    - 매일 발생 요금: 500만 * 5 * 0.3GB * $0.02 = $150,000
#### 2단계 - 개략적 설계안 제시 및 동의 구하기
- 시스템 설계 면접은 밑바닥부터 만드는 것과 관계가 없기 때문에 BLOB 저장소를 쓸 것이라면 그 사실만 언급해도 충분하다.
- 사용자 단말, CDN, API 서버 세 개 컴포넌트로 구성된다.
  - 단말: 컴퓨터, 모바일 폰, 스마트 TV
  - CDN: 비디오는 CDN에 저장
  - API 서버: 비디오 스트리밍을 제외한 모든 요청 (피드 추천, 비디오 업로드 URL 생성, 메타데이터 데이터베이스와 캐시 갱신, 사용자 가입 등)
- **비디오 업로드 절차**
  - 구성 컴포넌트
    - 사용자
    - 로드밸런서
    - API 서버
    - 메타데이터 데이터베이스: 비디오의 메타데이터 보관, 샤딩과 다중화를 적용해 성능 및 가용성 충족
    - 메타데이터 캐시: 성능을 높이기 위해 비디오 메타데이터와 사용자 객체 캐시
    - 원본 저장소: 원본 비디오를 보관할 대형 이진 파일 저장소 (BLOB: Binary Large Object storage)
    - 트랜스코딩 서버: 비디오 인코딩, 단말의 대역폭 요구사항에 맞는 최적의 비디오 스트림 제공위해 비디오의 포맷을 변환
    - 트랜스코딩 비디오 저장소: 트랜스코딩이 완료된 비디오 저장하는 BLOB 저장소
    - CDN
    - 트랜스코딩 완료 큐: 비디오 트랜스코딩 완료 이벤트들을 보관
    - 트랜스코딩 완료 핸들러: 트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내 메타데이터 캐시와 데이터베이스 갱신
  - **프로세스 a:비디오 업로드**
    - 비디오를 원본 저장소에 업로드
    - 트랜스코딩 서버에서 트랜스코딩 시작
    - 트랜스코딩 완료되면 트랜스코딩 비디오 저장소에 업로드 / 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣는 작업 병렬적으로 처리
      - CDN에 업로드 / 메타데이터베이스와 캐시 갱신
    - API 서버가 단말에게 비디오 업로드가 끝나 스트리밍 준비가 되었음을 알림
  - **프로세스 b:메타데이터 갱신**
    - 단말에서 메타데이터 갱신 요청을 API 서버에 보냄 (파일 이름, 크기, 포맷 등)
- **비디오 스트리밍 절차**
  - 스트리밍 프로토콜: MPEG-DASH, 애플 HLS, 마이크로소프트 스무드 스트리밍, 어도비 HTTP 동적 스트리밍
    - 동작 원리나 이름은 몰라도 되는데 프로토콜마다 지원하는 비디오 인코딩이 다르고 플레이어가 다르다는 것을 기억해야 한다.
  - CDN 엣지 서버에서 비디오 전송
#### 3단계 - 상세 설계
- **비디오 트랜스코딩**
  - 비디오가 다양한 단말에서 순조롭게 재생되려면 호환되는 비트레이트와 포맷으로 저장되어야 한다. (비디오를 구성하는 비트가 얼마나 빨리 처리되어야 하는지를 나타내는 단위)
  - 트랜스코딩이 중요한 이유
    - 원본 비디오는 저장 공간을 많이 차지한다.
    - 상당수의 단말과 브라우저는 특정 종류의 비디오 포맷만 지원한다. ->  하나의 비디오를 여러 포맷으로 인코딩하는게 바람직
    - 네트워크 대역폭이 충분하지 않은 사용자에겐 저화질, 충분한 사용자에게는 고화질 비디오 제공
    - 모바일 단말의 경우 네트워크 환경이 수시로 바뀌므로 비디오 화질을 자동 / 수동 변경하는 기능 필요
  - 인코딩 포맷
    - 컨테이너: 비디오 파일, 오디오, 메타데이터를 담는 바구니
    - 코덱: 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘
- **유향 비순환 그래프(DAG) 모델**
  - 각기 다른 비디오 프로세싱 파이프라인을 적절한 추상화를 도입해 클라이언트 프로그래머로 하여금 실행할 작업을 손수 정의할 수 있도록 한다.
  - 작업을 단계별로 배열할 수 있도록 하여 해당 작업들이 순차적으로 또는 병렬적으로 실행
~~~
         -> 비디오    -> 검사/인코딩/섬네일 추출 등   ->
원본 비디오 -> 오디오    -> 오디오 인코딩             -> 병합
         -> 메타데이터
~~~
  - 비디오 부분에 적용되는 작업
    - 검사: 품질이나 손상여부 확인
    - 비디오 인코딩: 비디오를 다양한 해상도, 코덱, 비트레이트 조합으로 인코딩하는 작업
    - 섬네일: 사용자가 업로드한 이미지나 비디오에서 자동 추출된 이미지로 섬네일 생성
    - 워터마크: 비디오에 대한 식별정보를 이미지 위에 오버레이
- **비디오 트랜스코딩 아키텍처**
~~~
  --------------------------------> 임시 저장소
  |                                     ↑
전처리기 -> DAG 스케줄러 -> 자원 관리자 -> 작업 실행 서버 -> 인코딩된 비디오
~~~
  - 전처리기
    - 비디오 분할: 비디오 스트림을 GOP라고 불리는 단위로 쪼갠다. 하나의 GOP는 독립적으로 재생 가능하다.
    - DAG 생성: 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG를 생성한다.
    - 데이터 캐시: 분할된 비디오의 캐시, 안정성을 높이기 위해 GOP와 메타데이터를 임시저장소에 보관, 인코딩 실패시 재개할 때 사용
  - DAG 스케줄러
    - DAG 그래프를 몇 단계로 분할한 다음 자원 관리자의 작업 큐에 삽입
  - 자원 관리자
    - 자원 배분을 효과적으로 수행
    - 작업 큐, 작업 서버 큐, 실행 큐, 작업 스케줄러로 구성
    - 동작 
      - 작업 관리자는 작업 큐에서 가장 높은 우선순위 작업 꺼냄
      - 해당 작업 실행하기 적합한 작업 서버 선택
      - 작업 스케줄러는 해당 작업 서버에게 작업 실행 지시
      - 작업 스케줄러는 어떤 서버에게 할당되었는지 정보를 실행 큐에 삽입
      - 작업이 완료되면 해당 작업을 실행 큐에서 제거
  - 작업 서버
    - DAG에 정의된 작업 수행
  - 임시 저장소
    - 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간 등에 따라 시스템 선택
  - 인코딩된 비디오
    - 최종 결과물
- **시스템 최적화**
  - 속도 최적화: 비디오 병렬 업로드
    - 분할한 GOP를 병렬적으로 업로드
  - 속도 최적화: 업로드 센터를 사용자 근거리에 지정
    - CDN 이용
  - 속도 최적화: 모든 절차를 병렬화
    - 느슨하게 결합된 시스템을 만들어서 병렬성을 높임
    - 메시지 큐를 사용해 보관된 이벤트 각각을 병렬처리
  - 안전성 최적화: 미리 사인된 업로드 URL
    - 허가받은 사용자만이 올바른 장소에 업로드 하기위해 사용
  - 안전성 최적화: 비디오 보호
    - 디지털 저작권 관리 시스템 도입
    - AES 암호화
    - 워터마크
  - 비용 최적화
    - 유튜브 비디오 스트리밍은 롱테일 분포를 따른다.
    1. 인기 비디오는 CDN을 통해 재생, 다른 비디오는 비디오 서버를 통해 재생
    2. 인기가 없는 비디오라면 인코딩 필요 X
    3. 어떤 비디오는 특정 지역에만 인기가 높으므로 다른 지역에 옮길 필요 없음
    4. CDN을 직접 구축하고 인터넷 서비스 제공자와 제휴
    - 최적화를 시도하기 전에 시청 패턴을 분석하는 것은 중요하다.
- **오류 처리**
  - 회복 가능 오류: 트랜스코딩 실패등의 오류, 몇 번 재시도
  - 회복 불가능 오류: 비디오 포맷 잘못된 오류, 해당 비디오에 대한 작업 중단
  - 오류와 전형적 해결방법
    - 업로드 오류: 몇 회 재시도
    - 비디오 분할 오류: 전체 비디오를 서버로 전송하고, 서버가 해당 비디오 분할
    - 트랜스코딩 오류: 재시도
    - 전처리 오류: DAG 그래프 재생성
    - DAG 스케줄러 오류: 작업을 다시 스케줄링
    - 자원 관리자 큐에 장애 발생: replica 이용
    - 작업 서버 장애: 다른 서버에서 재시도
    - API 서버 장애: 신규 요청 다른 서버로 우회
    - 메타데이터 캐시 서버 장애: 다른 노드에서 데이터 가져옴
    - 메타데이터 데이터베이스 서버 장애: 주 서버가 죽었으면 부 서버로 교체, 부 서버가 죽었으면 다른 부 서버를 통해 연산 처리
#### 4단계 - 마무리
- **추가 논의 사항**
  - API 계층의 규모 확장성 확보 방안
  - 데이터베이스 계층의 규모 확장성 확보 방안
  - 라이브 스트리밍: 라이브 스트리밍의 경우 응답지연이 더 낮아야 한다.
  - 비디오 삭제
#### 💡 느낀 점
- 예상 설계로 CDN과 추천 알고리즘 설계하는 것을 생각했으나, 일부는 맞고 일부는 틀렸다. CDN은 설계에 포함되었지만 추천 알고리즘은 포함되지 않았다.
- 비디오를 다루는 데에는 많은 기술이 필요하다는 사실을 알았다. 포멧부터 인코딩 작업, 클라이언트에 따른 호환성을 고려하기 위해 트랜스 코딩등의 작업등이 필요했다.
- 시스템을 설계할 때 특정 도메인에 대한 분석이 선행되어야 한다는 사실을 깨닫게 됐다.