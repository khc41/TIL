## 📅 2025-09-29
### 📖 읽은 블로그: [우리의 애플리케이션에서 PreparedStatement는 어떻게 동작하고 있는가](https://tech.kakaopay.com/post/how-preparedstatement-works-in-our-apps/)
#### ✏️ 세 줄 요약
- PreparedStatement가 어떻게 동작하고 있을지 궁금해서 Hibernate -> HikariCP -> MySQL Connector/J 순으로 분석하며 캐시 방식을 확인해봤다.
- preparedStatement 관련 옵션들이 MySQL Connector/J에 있었고, 옵션을 바꿔가며 성능 테스트를 했는데 결과는 크게 차이가 없었다.
- 엔터프라이즈 애플리케이션에서는 옵션들을 모두 활성화하는게 모범 사례인데, 생성할 수 있는 preparedStatement의 개수를 적절히 조정해야하고, Connection 당 캐시로 구현하기에 캐시 히트율이 떨어질 수 있다.
#### 💡 느낀 점
- PreparedStatement가 단순히 SQL Injection을 방지하는 도구로만 알고 있었는데, 이번 기회에 어떤식으로 동작하고 있는지 알게되어 좋았다.
- 특히, HikariCP에서 캐시를 안하는 이유가 Connection당 캐시를 하기 때문에 캐시 히트율이 떨어질 수 있어 더 아래 레이어한테 위임하는 부분이 인상 깊었다.
- 성능 테스트 결과 캐시 옵션을 키는게 성능이 좋을 줄 알았는데, 큰 차이가 없어서 놀라웠다.
- 엔터프라이즈 애플리케이션에서는 이러한 옵션을 키게되면 다양한 쿼리가 발생할 것이니, 캐시되는 preparedStatement의 개수에 유의해야할 것 같았다.
- 마지막으로, Entity에 @DynamicInsert, @DynamicUpdate는 쿼리를 새로 생성해 preparedStatement의 캐시 히트율을 낮춘다는 것을 보고 가급적 사용을 지양해야겠다는 생각이 들었다. 