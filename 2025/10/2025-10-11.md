## 📅 2025-10-11
### 📖 읽은 블로그: [지연이체 서비스 개발기: 은행 점검 시간 끝나면 송금해 드릴게요! (feat. 발표 후기)](https://tech.kakaopay.com/post/ifkakao2024-delayed-transfer/)
#### ✏️ 세 줄 요약
- 내규상 사내 공용 큐를 Kafka로 정했고, 기존에 RabbitMQ를 사용하던 지연이체 서비스의 아키텍쳐를 변경해야했다.
- 5분마다 디비를 읽어서 송금 요청을 해주는 스케쥴러를 개발했는데, 성능과 부하문제 때문에 kafka와 consumer를 활용했다.
- 토픽에 같은 송금 건이 쌓이는 경우, Consumer에서 같은 송금 건을 consume하는 경우, 유저락으로 송금 실패할 경우를 각각 고려해 개선했고, 파티션 수나 멀티 스레드등을 사용해 성능을 개선했다.
    - DB에 상태 컬럼을 같이 넣어서 중복 publish를 방지했다.
    - 중복 consume을 방지하기 위해 송금을 실행하고 상태를 변경하는 부분에 유저락을 사용했다.
    - 같은 사용자의 모든 송금건은 같은 Consumer가 처리하도록 해서 유저락 충돌을 줄였다.
#### 💡 느낀 점
- 충돌이 적은 상황에서 낙관락을 사용안하고 유저락을 사용한 이유는 충돌 처리를 파티션을 나눠서 해결한 부분도 있어서 충돌에 대한 성능차이도 크지 않기도 하고, 데이터 정합성을 위해서 선택을 했다는게 느껴졌다. 
- consumer에서 송금 서비스로 메시지를 처리하는 코드에서 예외가 발생하는 경우, 개별 처리가 아닌 메시지 전체를 처리하도록 되어있는데 그러면 송금 서비스쪽에서 멱등성이 중요해질 것 같다고 생각이 들었다.
- 만약, 대규모 트래픽 상황이라면 컨슈머 내에서 실패한 특정 메시지에 대해서만 처리를 해주는 로직이 있다면 부하를 견디는데 더 좋을거 같다는 생각이 들었다.
- user_id로 파티션을 나눴는데, 핫스팟 문제가 발생할 수도 있다는 생각이 들었다. 근데 사실 제한된 시간 사이에 송금이 적을 것으로 판단되기도 하고, 유저락 충돌이라는 다른 문제를 해결하기 위한 트레이드 오프로 보인다.