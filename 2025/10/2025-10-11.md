## 📅 2025-10-11
### 📖 읽은 블로그: [지연이체 서비스 개발기: 은행 점검 시간 끝나면 송금해 드릴게요! (feat. 발표 후기)](https://tech.kakaopay.com/post/ifkakao2024-delayed-transfer/)
#### ✏️ 세 줄 요약
- 내규상 사내 공용 큐를 Kafka로 정했고, 기존에 RabbitMQ를 사용하던 지연이체 서비스의 아키텍쳐를 변경해야했다.
- 5분마다 디비를 읽어서 송금 요청을 해주는 스케쥴러를 개발했는데, 성능과 부하문제 때문에 kafka와 consumer를 활용했다.
- 토픽에 같은 송금 건이 쌓이는 경우, Consumer에서 같은 송금 건을 consume하는 경우, 유저락으로 송금 실패할 경우를 각각 고려해 개선했고, 파티션 수나 멀티 스레드등을 사용해 성능을 개선했다.
    - DB에 상태 컬럼을 같이 넣어서 중복 publish를 방지했다.
    - 중복 consume을 방지하기 위해 송금을 실행하고 상태를 변경하는 부분에 유저락을 사용했다.
    - 같은 사용자의 모든 송금건은 같은 Consumer가 처리하도록 해서 유저락 충돌을 줄였다.
#### 💡 느낀 점
- 충돌이 적은 상황에서 낙관락을 사용안하고 유저락을 사용한 이유는 충돌 처리를 파티션을 나눠서 해결한 부분도 있어서 충돌에 대한 성능차이도 크지 않기도 하고, 데이터 정합성을 위해서 선택을 했다는게 느껴졌다. 
- consumer에서 송금 서비스로 메시지를 처리하는 코드에서 예외가 발생하는 경우, 개별 처리가 아닌 메시지 전체를 처리하도록 되어있는데 그러면 송금 서비스쪽에서 멱등성이 중요해질 것 같다고 생각이 들었다.
- 만약, 대규모 트래픽 상황이라면 컨슈머 내에서 실패한 특정 메시지에 대해서만 처리를 해주는 로직이 있다면 부하를 견디는데 더 좋을거 같다는 생각이 들었다.
- user_id로 파티션을 나눴는데, 핫스팟 문제가 발생할 수도 있다는 생각이 들었다. 근데 사실 제한된 시간 사이에 송금이 적을 것으로 판단되기도 하고, 유저락 충돌이라는 다른 문제를 해결하기 위한 트레이드 오프로 보인다.

---

### 📚 읽은 개발 서적: [데이터 중심 애플리케이션 설계](https://www.yes24.com/Product/Goods/59566585?pid=123487&cosemkid=go16406746660905354&utm_source=google_pc&utm_medium=cpc&utm_campaign=book_pc&utm_content=ys_240530_google_pc_cc_book_pc_12110%EB%8F%84%EC%84%9C2&utm_term=%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A4%91%EC%8B%AC%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%84%A4%EA%B3%84&gad_source=1&gad_campaignid=6762605740&gbraid=0AAAAAD79Irrfvaqb4HDi15JUqflihSilR&gclid=Cj0KCQjw3aLHBhDTARIsAIRij5-GpSKsMKO8XIATcjMBStXbk-93KGuGTmn0kK3NAbsbDtX417fNAIUaAih4EALw_wcB)
#### 7장. 트랜잭션
##### 커밋 후 읽기
- 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다.(더티 읽기 없음)
- 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다.(더티 쓰기 없음)
  - 로우 수준 잠금을 사용해 더티 쓰기 방지
  - 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억한 후, 커밋이 되기 전엔 과거의 값을 읽게 함으로써 더티 읽기 방지
##### 스냅숏 격리와 반복 읽기
- 커밋 후 읽기는 동시성 버그가 생길 수 있다.
  - 예를 들면 계좌 이체 상황인 경우 100원을 A계좌에서 B계좌로 이체한다고 했을 때, 송금 전 A 계좌에서 잔액을 읽고 송금 후 B 계좌에서 잔액을 읽으면 100원이 사라진 것처럼 보일 수 있다.
  - 이것을 비반복 읽기나 읽기 스큐라고 한다.
  - 새로고침하면 일관성이 맞겠지만, 백업이나 분석 질의 같은 경우 일관성이 맞지 않는 데이터를 읽을 수 있다.
  - 이런 문제를 해결하기 위해 각 트랜잭션이 일관된 스냅숏으로부터 읽는 스냅숏 격리가 있다.
- 여러 트랜잭션에서 다른 시점의 데이터베이스 상태를 봐야할 수 있기 대문에 다중 버전 동시성 제어(MVCC)로 해결한다.
##### 갱신 손실 방지
- 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 (read-modify-write 주기) 발생할 수 있다.
  - 예를들면 동시에 카운터를 읽고 증가시키는 경우 갱신 손실이 발생할 수 있다.
- **원자적 쓰기 연산**
  - update counters set value = value + 1 where id = 1;
  - 대부분의 관계형 데이터베이스에서 동시성 안전하다.
  - 객체에 독점적인 잠금을 획득하거나 단일 스레드에서 실행되도록 강제해서 구현할 수 있다.
- **명시적인 잠금**
  - for update 구문등을 사용해 명시적으로 잠궈 read-modify-write 주기가 완료될 때까지 기다리도록 강제한다.
  - 필요한 잠금을 추가하는 것을 잊어버려서 경쟁조건을 유발하기 쉽다.
- **갱신 손실 자동 감지**
  - 갱신 손실을 발견하면 어보트시키고 재시도하도록 하는 방법이다.
  - 특별한 데이터베이스 기능도 쓸 필요 없으므로 매우 좋은 기능이나 잠금이나 원자적 연산을 쓰는 것을 잊어버려서 버그를 유발할 수 있다.
- **Compare-and-set**
  - 갱신이 적용됐는지 확인하고 필요하다면 재시도해야 하지만, where 절이 오래된 스냅숏으로부터 읽는 것을 허용한다면 갱신 손실을 막지 못할 수도 있다.
- **충돌 해소와 복제**
  - 잠금과 compare-and-set은 단일 노드에서만 작동한다.
  - 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전을 생성하는 것을 허용하고, 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합한다.
  - 최종 쓰기 승리는 갱신 손실이 발생하기 쉽다.
##### 쓰기 스큐와 팬텀
- 의사들이 병원에서 교대로 서는 호출 대기를 관리하는 애플리케이션이 있을 때, 최소 한 명의 의사는 반드시 있어야한다고 가정한다. 앨리스와 밥이 동시에 호출 대기를 그만둔다면 각각 본인의 레코드를 갱신하므로, 최종적으로 호출 대기하는 의사가 한명도 없게 된다.
- 이런 현상을 쓰기 스큐라고 한다.
- **쓰기 스큐를 유발하는 팬텀**
  1. SELECT 질의가 어떤 요구사항을 만족하는지 확인한다.
  2. 첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정한다.
  3. 계속 처리하기로 했다면 데이터베이스에 쓰고 트랜잭션을 커밋한다.
  - 이처럼 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 팬텀이라고 한다.
- **충돌 구체화**
  - 인위적으로 데이터베이스에 잠금 객체를 추가하고, select for update 등으로 잠금을 획득하는 방법이다.
    - 예를들면, 회의실 시간 슬롯과 회의실에 대한 테이블을 생성한다.
  - 충돌을 구체화하는 방법을 알아내기 어렵고 오류가 발생하기 쉽다.
##### 직렬성
- 데이터베이스가 발생할 수 있는 모든 경쟁조건을 막아준다.
1. 트랜잭션을 순차적으로 실행하기
2. 2단계 잠금 사용
   - 읽는 쪽과 쓰는 쪽을 동시에 잠금을 사용해 구현한다. 
3. 직렬성 스냅숏 격리 같은 낙관적 동시성 제어 기법
   - 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘을 추가한다.
    
#### 💡 느낀 점
- 이 부분에 대해서 간단하게 책을 읽었었는데, 실제로 팬텀 리드에 대해 설명하려고 하니 생각이 정리가 안돼서 글로 남기게 됐다.
- 각 트랜잭션 격리 수준과 발생할 수 있는 문제에 대해 깊게 알게됐다. 특히, 반복 읽기에서 쓰기 스큐와 팬텀 리드에 대해 정확하게 알게됐다.
- 실제로 현업에서 이런 쓰기 스큐 문제를 직면했을 때, 어떤 방법으로 해결하는지 궁금하다. 그리고, 같은 트랜잭션 안에서 select 후 조건에 따라 쓰기를 하는 경우 주의해서 애플리케이션 로직을 작성해야한다고 생각이 들었다.