## 📅 2025-11-26
### 📖 읽은 블로그: [@RequestCache: HTTP 요청 범위 캐싱을 위한 커스텀 애너테이션 개발기](https://d2.naver.com/helloworld/7610642)
#### ✏️ 요약
- 같은 HTTP 요청 내에서 외부 API를 여러 번 호출하는 경우 불필요한 중복 호출이 발생할 수 있다. 이것을 해결하기 위해 @RequestCache 애너테이션을 개발했다.
- 대안으로 응답을 파라미터로 넘기는 것이나 Redis 등을 사용하는 것을 고려했지만 각각 불필요한 파라미터를 추가해야한다거나 TTL 설정의 어려움으로 적절치 못했다.
- 실행했을 때, Spring Actuator의 CacheMetricsAutoConfiguration와 충돌해 문제가 생겨서 커스텀 CacheManager를 구현해 해결했다.
- 하지만, @Async나 Kafka Consumer에서 사용하지 못하는 등의 제약이 아직 남아있고, 추가 개선이 필요하다.
#### 💡 느낀 점
- 처음 봤을 때 Redis로 HTTP 요청 자체를 캐싱하는 방법을 생각했었는데, 역시 블로그에서도 그것을 고민해봤고 TTL 설정에 문제가 있어 포기한 점이 인상 깊었다.
- @RequestScope를 CacheManager의 생성에 사용하면서 HTTP 생명주기와 같이 가도록 한 점이 흥미로웠는데, 이로 인해 Actuator와 충돌이 생긴 것을 내부코드까지 구체적으로 파악하면서 원인 분석한 점이 인상깊다.
- 싱글톤으로 커스텀 CacheManager를 정의해뒀을 때, 요청 별로 어떤식으로 캐시를 구분하지 생각했었는데 RequestAttributes로 Cache 객체를 저장하는 방식을 보고 치밀하게 설계됐다고 생각했다.
- 생명주기나 메모리 관리의 이슈로 ThreadLocal을 사용하지 못하는 것을 보고 확실히 시스템의 안정성을 위한 트레이드오프를 고려해야한다고 느꼈다.