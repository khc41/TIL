## 📅 2026-01-13
### 📚 읽은 개발 서적: [데이터 중심 애플리케이션 설계](https://www.yes24.com/Product/Goods/59566585?pid=123487&cosemkid=go16406746660905354&utm_source=google_pc&utm_medium=cpc&utm_campaign=book_pc&utm_content=ys_240530_google_pc_cc_book_pc_12110%EB%8F%84%EC%84%9C2&utm_term=%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A4%91%EC%8B%AC%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%84%A4%EA%B3%84&gad_source=1&gad_campaignid=6762605740&gbraid=0AAAAAD79Irrfvaqb4HDi15JUqflihSilR&gclid=Cj0KCQjw3aLHBhDTARIsAIRij5-GpSKsMKO8XIATcjMBStXbk-93KGuGTmn0kK3NAbsbDtX417fNAIUaAih4EALw_wcB)
#### 1장. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
- 오늘날 많은 애플리케이션은 데이터 중심적이여서 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 큰 문제로 다가오고 있다.
- 애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.
  - 데이터 저장 -> 데이터베이스
  - 읽기 속도 향상 -> 캐시
  - 데이터 검색이나 필터링 -> 검색 색인
  - 비동기 처리를 위한 메시지 보내기 -> 스트림 처리
  - 대량의 데이터 분석 -> 일괄 처리
##### 데이터 시스템에 대한 생각
- 데이터베이스, 큐, 캐시등을 데이터 시스템이라는 포괄적인 용어로 묶는 이유
  - 최근에 만들어진 데이터 저장과 처리를 위한 여러 새로운 도구들은 다양한 사용사례에 최적화 됐기 때문에 분류 간 경계가 흐려지고 있다.
  - 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고 있기 때문에 다양한 도구들을 애플리케이션 코드를 이용해 서로 연결한다.
- 이 책에서 중요하게 여기는 세 가지
  - 신뢰성
  - 확장성
  - 유지보수성
##### 신뢰성
- 무언가 잘못되더라도 지속적으로 올바르게 동작하는 것
- 잘못될 수 있는 일을 결함이라하고 결함을 예측하고 대처할 수 있는 시스템을 내결함성 또는 탄력성을 지녔다고 말한다.
- 결함은 사양에서 벗어난 시스템의 한 구성요소로 정의되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우이므로 결함은 장애와 동일하지 않다.
- 결함 확률을 0으로 줄이는 것은 불가능하므로 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장 좋다.
- **하드웨어 결함**
  - 램에 결함이 생기거나 대규모 정전사태가 발생하는 것과 같은 결함
  - 시스템 장애율을 줄이기 위해 각 하드웨어 구성 요소에 중복을 추가하는 방법이 일반적이다. 
  - 최근까지 단일 장비의 전체 장애는 매우 드물기 때문에 대부분의 애플리케이션은 하드웨어 구성요소의 중복으로 충분했다.
  - 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 더 많은 애플리케이션이 많은 수의 장비를 사용하게 됐고 이와 비례해 하드웨어 결함율도 증가했다.
  - 따라서 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손신을 견딜 수 있는 시스템으로 점점 옮겨가고 있다.
    - 전체 시스템의 중단 없이 한 번에 한 노드 씩 패치할 수 있는 장점이 있다.
- **소프트웨어 오류**
  - 예상하기 어려운 결함으로 노드 간 상관관계 때문에 상관관계 없는 하드웨어 결함보다 오히려 시스템 오류를 더욱 많이 유발하는 경향이 있다.
  - 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않는다.
  - 문제 해결에 도움을 줄 수 있는 방법
    - 시스템 가정과 상호작용에 대해 주의깊게 생각하기
    - 빈틈없는 테스트
    - 프로세스 격리
    - 죽은 프로세스의 재시작 허용
    - 프로덕션 환경에서 시스템 동작의 측정
    - 모니터링 분석하기
    - 작업 수행중 지속적으로 확인해 차이가 날 경우 경고 발생
- **인적 오류**
  - 운영자의 설정 오류가 대규모 인터넷 서비스 중단에 주요 원인이다.
  - 신뢰성 있게 만드는 방법
    - 오류의 가능성을 최소화하는 방향으로 시스템을 설계해라
    - 가장 많이 실수하는 장소에서 실수로 장애가 발생할 수 있는 부분을 분리하라
    - 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라
    - 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있게 하라
    - 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련해라
    - 조작 교육과 실습을 시행하라
##### 확장성
- 부하가 증가하면 시스템이 안정적으로 동작하지 못할 수 있다.
- 증가한 부하에 대처하는 시스템 능력을 확장성이라고 한다.
- **부하 기술하기**
  - 부하 매개변수를 통해 간결하게 몇개의 숫자로 기술할 수 있다.
    - 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자, 캐시 적중률 등
  - 트위터의 사례
    - 초당 12000건의 쓰기보다 팬 아웃 때문에 확장성 문제가 일어난다.
    - 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백 배 적기 때문에 쓰기 시점에 더 많은 일을 하는 것이 바람직하다.
      - 각 사용자는 개별 홈 타임라인 캐시를 유지하고 사용자가 트윗을 작성하면 팔로워 각자의 캐시에 새로운 트윗을 삽입하는 방법
    - 일부 팔로워가 많은 사용자의 경우는 팬 아웃에서 제외되고 읽는 시점에 사용자의 홈 타임라인에 합친다.
- **성능 기술하기**
  - 처리량: 초당 처리할 수 있는 레코드 수
  - 응답시간: 클라이언트가 요청을 보내고 응답을 받는 사이의 시간
    - 응답시간은 매번 다르므로 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야 한다.
    - 백그라운드 프로세스의 컨텍스트 스위치, 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 휴지, 디스크에서 읽기를 강제하는 페이지 폴트, 서버 랙의 기계적인 진동이나 다른 여러 원인으로 추가 지연이 생길 수 있다.
    - 평균보다는 백분위를 사용하는 편이 좋다.
      - 꼬리 지연 시간이라고 알려진 p95, p99, p999등의 상위 백분위는 서비스 사용자 경험에 직접 영향을 주기 때문에 중요하다.
    - 서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지하는데 이 현상을 선두 차단이라 한다.
    - 요청을 처리하기 위해 여러 번 백엔드 호출이 필요한 경우 하나의 느린 백엔드 요청이 전체 응답 시간을 느리게 하는데 이를 꼬리 지연 증폭이라고 한다.
- **부하 대응 접근 방식**
  - 용량 확장(scaling up): 좀 더 강력한 장비로 이동
  - 규모 확장(scaling out): 다수의 낮은 사양 장비에 부하를 분산
  - 비공유(shared-nothing): 다수의 장비에 부하를 분산하는 아키텍쳐
  - 탄력적: 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있는 시스템
  - 다수의 장비에 상태 비저장 서비스를 배포하는 일은 간단하지만 단일 노드에 상태 유지 데이터 시스템을 분산 설치하는 일은 아주 많이 복잡하므로 확장 비용이나 데이터베이스를 분산으로 만들어야하는 고가용성 요구가 있을 때까지 단일 노드에 데이터베이스를 유지하는 것이 최근까지의 통념이다.
  - 범용적이고 모든 상황에 맞는 확장 아키텍쳐는 없고 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등으로 아키텍쳐가 결정된다.
##### 유지보수성
- 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가등이 유지보수이고, 소프트웨어 비용의 대부분에 속한다.
- 레거시 소프트웨어를 만들지 않게끔 설계하는 방법
  - 운용성: 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라
  - 단순성: 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라
  - 발전성: 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라.
- **운용성: 운영의 편리함 만들기**
  - 좋은 운영은 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다.
  - 자동화를 할 수 있지만 결국 제대로 동작하는지 확인하는 일은 사람의 몫이다.
  - 운영팀이 하는 일
    - 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 복원
    - 시스템 장애, 성능 저하 등의 문제의 원인을 추적
    - 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
    - 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
    - 미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결
    - 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
    - 애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보수 태스크를 수행
    - 설정 변경으로 생기는 시스템 보안 유지보수
    - 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
    - 개인 인사 이동에도 시스템에 대한 조직의 지식을 보존
  - 좋은 운영성을 위해 데이터 시스템이 할 일
    - 좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공
    - 표준 도구를 이용해 자동화와 통합을 위한 우수한 지원을 제공
    - 개별 장비 의존성을 회피
    - 좋은 문서와 이해하기 쉬운 운영 모델 제공
    - 만족할 만한 기본 동작을 제공하고 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
    - 적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
    - 예측 가능하게 동작하고 예기치 않은 상황을 최소화함
- **단순성: 복잡도 관리**
  - 복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게 하고 나아가 유지보수 비용이 증가한다.
  - 복잡도는 상태 공간의 급증, 모듈 간 강한 커플링, 복잡한 의존성, 일관성 없는 명명과 용어, 성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례등이 있다.
  - 복잡도는 변경이 있을 때 버그가 생길 위험이 더 크므로 복잡도를 줄이면 유지보수성이 크게 향상된다.
  - 우발적 복잡도
    - 제거하기 위한 최상의 도구는 추상화고 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.
    - 다양한 애플리케잇녀에서도 재사용 가능하므로 고품질 소프트웨어로 이어진다.
- **발전성: 변화를 쉽게 만들기**
  - 시스템의 요구사항은 끊임없이 바뀐다.

#### 💡 느낀 점
- 책에서 강조하는 것은 최근에는 복잡한 요구사항과 문제를 해결하기 위한 다양한 도구가 존재하고 그것을 잘 활용해 문제에 맞는 아키텍쳐를 설계하는 것이 중요하다고 생각된다.
- 좋은 소프트웨어를 만들기 위해 신뢰성, 확장성, 유지보수성 등의 측면을 강조했는데 개발을 하는 입장에서 정확히 세 부분으로 나눠서 짚어주고 있다는 생각이 들었다.
- 이 책에서는 간단하게 개념 설명 위주로 나왔지만 각각은 많은 내용을 함축하고 있고, 공부해야할 것이 많다고 느꼈다.