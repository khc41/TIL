## 📅 2026-02-03
### 📚 읽은 개발 서적: [데이터 중심 애플리케이션 설계](https://www.yes24.com/Product/Goods/59566585?pid=123487&cosemkid=go16406746660905354&utm_source=google_pc&utm_medium=cpc&utm_campaign=book_pc&utm_content=ys_240530_google_pc_cc_book_pc_12110%EB%8F%84%EC%84%9C2&utm_term=%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A4%91%EC%8B%AC%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%84%A4%EA%B3%84&gad_source=1&gad_campaignid=6762605740&gbraid=0AAAAAD79Irrfvaqb4HDi15JUqflihSilR&gclid=Cj0KCQjw3aLHBhDTARIsAIRij5-GpSKsMKO8XIATcjMBStXbk-93KGuGTmn0kK3NAbsbDtX417fNAIUaAih4EALw_wcB)
#### 3장. 저장소와 검색
- 애플리케이션 개발자는 특정 작업부하 유형에서 좋은 성능을 내게끔 저장소 엔진을 선택해야하므로, 저장소 엔진 내부에서 수행되는 작업에 대해 대략적인 개념을 이해해야 한다.
##### 데이터베이스를 강력하게 만드는 데이터 구조
- 세상에서 가장 간단한 데이터베이스는 매 라인마다 쉼표로 구분된 키-값 쌍을 포함한 텍스트 파일이다.
- 파일의 끝에 추가해 이전 버전을 덮어쓰지 않고, 최신 값을 찾기 위해서는 키의 마지막 항목을 살펴봐야 한다.
- 파일 추가 작업이 매우 효율적이고, 많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그를 사용한다.
- 읽기는 많은 레코드가 있으면 성능이 매우 좋지 않고 검색 비용이 O(N)이여서 색인이 필요하다.
- 색인
  - 부가적인 메타데이터를 유지해 원하는 데이터의 위치를 찾는 데 도움을 준다.
  - 추가적인 데이터 구조라 데이터를 쓸 때마다 오버헤드가 발생한다.
  - 읽기 질의 속도는 향상시키지만, 쓰기 속도는 떨어뜨려서 전형적인 질의 패턴에 대한 지식을 활용해 수동으로 색인을 선택해야 한다.
- **해시 색인**
  - 키-값 저장소는 dictionary 타입과 매우 유사해 보통 해시 맵(해시 테이블)으로 구현한다.
  - 키를 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략이다.
  - 비트캐스크가 근본적으로 사용하는 방식으로 해시 맵을 전부 메모리에 유지하기 때문에 고성능 읽기, 쓰기를 보장한다.
    - 각 키의 값이 자주 갱신되는 상황, 즉 쓰기가 아주 많지만 고유 키가 많지 않은 경우에 매우 적합하다.
  - 파일에 항상 추가만 한다면 디스크 공간이 부족해지므로 특정 크기의 세그먼트로 로그로 나누는 방식이 좋은 해결책이다.
    - 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 **컴팩션** 작업을 수행한다.
    - 컴팩션은 세그먼트를 더 작게 만들기 때문에 컴팩션을 수행할 때 동시에 여러 세그먼트들을 병합할 수 있다.
    - 병합과 컴팩션은 백그라운드에서 수행하므로 읽기와 쓰기를 정상적으로 수행가능하고, 병합이 끝난 뒤에는 이전 세그먼트 대신 새로운 세그먼트를 사용하게끔 전환한다.
  - 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖고, 키의 값을 찾으려면 가장 최신 세그먼트 해시 맵을 먼저 확인한다.
  - 고려사항
    - 파일 형식: CSV보다 바이너리 형식을 사용하는 편이 빠르고 간단하다.
    - 레코드 삭제: 키와 관련된 값을 삭제하려면 특수한 삭제 레코드(툼스톤)을 추가해야한다. 병합 과정에서 삭제된 키의 이전 값을 무시하게 된다.
    - 고장 복구: 재시작 되면 인메모리 해시 맵이 손실되므로 전체 세그먼트 파일을 처음부터 끝까지 읽어 해시맵을 복원할 수 있지만 오래걸릴 수 있으므로 스냅숏을 디스크에 저장해 복구 속도를 높인다.
    - 부분적으로 레코드 쓰기: 로그에 레코드를 추가하는 도중 죽을 수 있으므로 체크섬을 포함해 로그의 손상된 부분을 탐지해 무시할 수 있다.
    - 동시성 제어: 하나의 쓰기 쓰레드만 사용하는 것이 일반적이다. 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시에 읽기를 할 수 있다.
  - 추가 전용 로그
    - 추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 무작위 쓰기보다 훨씬 빠르다.
    - 세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장 복구는 훨씬 간단하다.
    - 오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있다.
  - 제한 사항
    - 해시 테이블은 메모리에 저장하므로 키가 너무 많으면 안된다.
    - 해시 테이블은 범위 질의에 효율적이지 않다.
- **SS테이블과 LSM 트리**
  - 세그먼트 파일의 형식에 키-값 쌍을 키로 정렬하면 정렬된 문자열 테이블(Sorted String Table, SSTable)이라고 한다.
  - SS테이블의 장점
    - 세그먼트 병합 과정이 병합정렬 알고리즘과 유사하며, 각 세그먼트에서 첫 번째 키를 출력 파일로 복사한 뒤 과정을 반복해 간단하고 효율적이다.
    - 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없다.
      - 정렬돼 있으므로 일부 키에 대해서만 인메모리 색인을 가지고 스캔하면 된다.
    - 읽기 요청은 요청 범위 내에서 여러 키-값 쌍을ㄴㅁㅇ 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축하므로 I/O 대역폭 사용을 줄인다.
  - **SS테이블의 생성과 유지**
    - 유입되는 쓰기는 임의로 이루어지므로 메모리에 레드블랙트리나 AVL 트리 등으로 정렬된 순서를 유지할 수 있다.
      - 쓰기가 들어오면 멤테이블이라는 인메모리 균형 트리에 추가한다.
      - 멤테이블이 임곗값보다 커지면 SS테이블 파일로 디스크에 기록한다. SS테이블 파일은 가장 최신 세그먼트가 된다.
      - 읽기 요청이 오면 멤테이블 -> 최신 세그먼트 순서로 찾는다.
      - 백그라운드에서 병합과 컴팩션이 수행된다.
    - 데이터베이스가 고장나면 멤테이블이 손실되므로 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상에 유지해야 한다.

#### 💡 느낀 점
- 가장 단순한 형태의 데이터베이스로부터 시작해 현재의 데이터베이스에 이르기까지 그 과정을 설명해줘서 데이터베이스에 대해서 더 잘 이해할 수 있었다.
- 색인 구조에 대해서 어떻게 생겼는지와 쓰기 성능에 영향을 끼칠 수 있으므로 색인을 생성할 때 주의하라고 하는데 이 부분에 대해서 인덱스 테이블을 새로 생성해야하기 때문에 쓰기 성능에 영향을 끼친다는 근본적인 원리를 알 수 있게 돼서 좋았다.
