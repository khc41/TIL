## 📅 2026-02-09
### 📚 읽은 개발 서적: [데이터 중심 애플리케이션 설계](https://www.yes24.com/Product/Goods/59566585?pid=123487&cosemkid=go16406746660905354&utm_source=google_pc&utm_medium=cpc&utm_campaign=book_pc&utm_content=ys_240530_google_pc_cc_book_pc_12110%EB%8F%84%EC%84%9C2&utm_term=%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A4%91%EC%8B%AC%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%84%A4%EA%B3%84&gad_source=1&gad_campaignid=6762605740&gbraid=0AAAAAD79Irrfvaqb4HDi15JUqflihSilR&gclid=Cj0KCQjw3aLHBhDTARIsAIRij5-GpSKsMKO8XIATcjMBStXbk-93KGuGTmn0kK3NAbsbDtX417fNAIUaAih4EALw_wcB)
#### 3장. 저장소와 검색
- 애플리케이션 개발자는 특정 작업부하 유형에서 좋은 성능을 내게끔 저장소 엔진을 선택해야하므로, 저장소 엔진 내부에서 수행되는 작업에 대해 대략적인 개념을 이해해야 한다.
##### 데이터베이스를 강력하게 만드는 데이터 구조
- 세상에서 가장 간단한 데이터베이스는 매 라인마다 쉼표로 구분된 키-값 쌍을 포함한 텍스트 파일이다.
- 파일의 끝에 추가해 이전 버전을 덮어쓰지 않고, 최신 값을 찾기 위해서는 키의 마지막 항목을 살펴봐야 한다.
- 파일 추가 작업이 매우 효율적이고, 많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그를 사용한다.
- 읽기는 많은 레코드가 있으면 성능이 매우 좋지 않고 검색 비용이 O(N)이여서 색인이 필요하다.
- 색인
  - 부가적인 메타데이터를 유지해 원하는 데이터의 위치를 찾는 데 도움을 준다.
  - 추가적인 데이터 구조라 데이터를 쓸 때마다 오버헤드가 발생한다.
  - 읽기 질의 속도는 향상시키지만, 쓰기 속도는 떨어뜨려서 전형적인 질의 패턴에 대한 지식을 활용해 수동으로 색인을 선택해야 한다.
- **해시 색인**
  - 키-값 저장소는 dictionary 타입과 매우 유사해 보통 해시 맵(해시 테이블)으로 구현한다.
  - 키를 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략이다.
  - 비트캐스크가 근본적으로 사용하는 방식으로 해시 맵을 전부 메모리에 유지하기 때문에 고성능 읽기, 쓰기를 보장한다.
    - 각 키의 값이 자주 갱신되는 상황, 즉 쓰기가 아주 많지만 고유 키가 많지 않은 경우에 매우 적합하다.
  - 파일에 항상 추가만 한다면 디스크 공간이 부족해지므로 특정 크기의 세그먼트로 로그로 나누는 방식이 좋은 해결책이다.
    - 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 **컴팩션** 작업을 수행한다.
    - 컴팩션은 세그먼트를 더 작게 만들기 때문에 컴팩션을 수행할 때 동시에 여러 세그먼트들을 병합할 수 있다.
    - 병합과 컴팩션은 백그라운드에서 수행하므로 읽기와 쓰기를 정상적으로 수행가능하고, 병합이 끝난 뒤에는 이전 세그먼트 대신 새로운 세그먼트를 사용하게끔 전환한다.
  - 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖고, 키의 값을 찾으려면 가장 최신 세그먼트 해시 맵을 먼저 확인한다.
  - 고려사항
    - 파일 형식: CSV보다 바이너리 형식을 사용하는 편이 빠르고 간단하다.
    - 레코드 삭제: 키와 관련된 값을 삭제하려면 특수한 삭제 레코드(툼스톤)을 추가해야한다. 병합 과정에서 삭제된 키의 이전 값을 무시하게 된다.
    - 고장 복구: 재시작 되면 인메모리 해시 맵이 손실되므로 전체 세그먼트 파일을 처음부터 끝까지 읽어 해시맵을 복원할 수 있지만 오래걸릴 수 있으므로 스냅숏을 디스크에 저장해 복구 속도를 높인다.
    - 부분적으로 레코드 쓰기: 로그에 레코드를 추가하는 도중 죽을 수 있으므로 체크섬을 포함해 로그의 손상된 부분을 탐지해 무시할 수 있다.
    - 동시성 제어: 하나의 쓰기 쓰레드만 사용하는 것이 일반적이다. 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시에 읽기를 할 수 있다.
  - 추가 전용 로그
    - 추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 무작위 쓰기보다 훨씬 빠르다.
    - 세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장 복구는 훨씬 간단하다.
    - 오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있다.
  - 제한 사항
    - 해시 테이블은 메모리에 저장하므로 키가 너무 많으면 안된다.
    - 해시 테이블은 범위 질의에 효율적이지 않다.
- **SS테이블과 LSM 트리**
  - 세그먼트 파일의 형식에 키-값 쌍을 키로 정렬하면 정렬된 문자열 테이블(Sorted String Table, SSTable)이라고 한다.
  - SS테이블의 장점
    - 세그먼트 병합 과정이 병합정렬 알고리즘과 유사하며, 각 세그먼트에서 첫 번째 키를 출력 파일로 복사한 뒤 과정을 반복해 간단하고 효율적이다.
    - 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없다.
      - 정렬돼 있으므로 일부 키에 대해서만 인메모리 색인을 가지고 스캔하면 된다.
    - 읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축하므로 I/O 대역폭 사용을 줄인다.
  - **SS테이블의 생성과 유지**
    - 유입되는 쓰기는 임의로 이루어지므로 메모리에 레드블랙트리나 AVL 트리 등으로 정렬된 순서를 유지할 수 있다.
      - 쓰기가 들어오면 멤테이블이라는 인메모리 균형 트리에 추가한다.
      - 멤테이블이 임곗값보다 커지면 SS테이블 파일로 디스크에 기록한다. SS테이블 파일은 가장 최신 세그먼트가 된다.
      - 읽기 요청이 오면 멤테이블 -> 최신 세그먼트 순서로 찾는다.
      - 백그라운드에서 병합과 컴팩션이 수행된다.
    - 데이터베이스가 고장나면 멤테이블이 손실되므로 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상에 유지해야 한다.
  - **성능 최적화**
    - LSM 트리 알고리즘은 데이터베이스에 존재하지 않는 키를 찾을 때 느리므로 블룸 필터를 추가적으로 사용한다.
    - SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략은 일반적으로 크기 계층 컴팩션과 레벨 컴팩션이다.
      - 크기 계층 컴팩션: 상대적으로 새롭고 작은 SS테이블을 상대적으로 오래되고 큰 SS테이블에 연이어 병합
      - 레벨 컴팩션: 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동
    - LSM트리는 백그라운드에서 연쇄적으로 SS 테이블을 지속적으로 병합하고, 디스크가 순차 쓰기이기 때문에 매우 높은 쓰기 처리량을 보장한다.
- **B 트리**
  - B 트리는 고정 크기 블록이나 페이지로 나누고 한번에 하나의 페이지에 읽기 또는 쓰기를 한다.
  - 각 페이지는 주소나 위치를 이용해 식별할 수 있는데 하나의 페이지가 다른 페이지를 참조할 수 있다.
  - 루트에서 시작해 하위 페이지로 내려가면서 개별 키를 포함하는 페이지에 도달한다.
  - 하위 페이지를 참조하는 수를 분기 계수라고 부른다.
  - 키의 값을 갱신하려면 키를 포함하고 있는 리프 페이지를 검색하고 페이지의 값을 바꾼 다음 페이지를 디스크에 다시 기록한다.
  - 새로운 키를 추가할 때 수용한 페이지에 충분한 공간이 없으면 페이지를 반쯤 채워진 페이지 둘로 나누고 상위 페이지가 새로운 키 범위의 하위 부분을 알 수 있게 갱신한다.
  - 트리가 계속 균형을 유지하는 것을 보장해서 O(log N)의 시간 복잡도로 검색이 가능하다.
  - **신뢰할 수 있는 B 트리 만들기**
    - 새로운 데이터를 디스크 상의 페이지에 덮어쓴다.
    - 삽입 때문에 페이지가 많아져 분할할 때 두 페이지를 기록하고 두 하위 페이지에 참조를 상위 페이지에서 갱신해야 하는데, 일부 페이지만 기록하고 데이터베이스가 고장나면 고아페이지가 생길 수 있다.
    - 고장 상황에서 스스로 복구하게 만들려면 쓰기 전 로그(write-ahead log, WAL)를 사용한다.
      - 변경된 내용을 적용하기 전에 모든 B 트리의 변경 사항을 기록하는 추가 전용 파일
    - 다중 스레드가 동시에 B 트리에 접근한다면 동시성 문제가 생기는데, 보통 래치로 동시성 제어를 한다.
  - **B 트리 최적화**
    - 덮어 쓰기와 고장 복구를 위한 WAL 유지 대신 변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가리키게 하는 쓰기 시 복사 방식을 사용한다.
    - 키를 축약해 써서 공간을 절약한다.
    - 질의가 정렬된 순서로 키 범위의 상당 부분을 스캔해야할 때 페이지들이 가까이 있지 않은 경우 디스크 스캔이 비효율적이기 때문에 리프 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치하려 시도한다.
    - 각 리프 페이지가 양쪽 형제 페이지에 대한 참조를 가지는 포인터를 추가해 상위 페이지로 가지 않고도 순서대로 키를 스캔 가능하다.
    - 프랙탈 트리
- **B 트리와 LSM 트리 비교**
  - LSM 트리는 쓰기에서, B 트리는 읽기에서 더 빠르다.
  - 벤치마크는 작업부하의 세부 사항에 민감하므로 실제 필요한 작업부하로 시스템을 테스트해야 한다.
  - **LSM 트리의 장점**
    - B 트리 색인은 쓰기 전 로그와 트리 페이지에 두 번 기록해야한다.
    - 로그 구조화 색인은 SS테이블의 반복된 컴팩션과 병합으로 여러 번의 디스크 쓰기를 야기하는데 이걸 쓰기 증폭이라 한다.
    - 쓰기가 많은 애플리케이션에서 쓰기 증폭은 성능 비용으로 작용한다.
    - LSM 트리는 쓰기 증폭이 더 낮고 순차적으로 컴팩션된 SS파일을 쓰기 때문에 B 트리보다 쓰기 처리량을 높게 유지할 수 있다. 
    - LSM 트리는 압축률이 더 좋아서 디스크에 더 적은 파일을 생성한다. 반면에 B 트리는 파편화로 인해 사용하지 않는 디스크 공간 일부가 남는다.
    - 대다수의 SSD 펌웨어는 낮은 쓰기 증폭화 파편화 감소를 위해 로그 구조화 알고리즘을 사용한다.
  - **LSM 트리의 단점**
    - 컴팩션 과정이 때로 진행 중인 읽기와 쓰기 성능에 영향을 준다.
    - 디스크가 가진 자원은 한계가 있기 때문에 비싼 컴팩션 연산이 끝날 때까지 요청이 대기해야 하는 상황이 발생하기 쉽다.
    - 쓰기 대역폭은 유한하므로 초기 쓰기, 멤테이블을 디스크로 방출, 백그라운드에서 수행되는 컴팩션 스레드가 대역폭을 공유해야 한다.
    - 컴팩션 설정을 주의 깊게 하지 않으면 컴팩션이 유입 쓰기 속도를 따라갈 수 없고, 결과적으론 디스크 공간이 부족할 때까지 병합되지 않은 세그먼트가 증가하고 읽기 또한 느려진다.
    - B 트리는 각 키가 색인의 한 곳에만 정확하게 존재하지만 로그 구조화 저장소 엔진은 다른 세그먼트에 같은 키의 다중 복사본이 존재할 수 있어서 강력한 트랜잭션 시맨틱은 B 트리가 훨씬 매력적이다.
    - 사용 사례에 적합한 저장소 엔진의 유형을 결정하기 위한 빠르고 쉬운 규칙은 없기 때문에 테스트를 통해 경험적으로 결정하는 방법도 나쁘지 않다.
- **기타 색인 구조**
  - 키-값 색인은 기본키 색인, 보조 색인 등이 있는데 차이점은 보조 색인은 키가 고유하지 않다는 점이다.
  - **색인 안에 값 저장하기**
    - 색인에서 값은 질문의 실제 로우거나 다른 곳에 저장된 로우를 가리키는 참조다.
    - 참조의 경우 로우가 저장된 곳을 힙 파일이라 하고 특정 순서 없이 데이터를 저장한다.
      - 힙 파일은 여러 보조 색인이 존재할 때 데이터 중복을 피할 수 있어서 일반적으로 사용된다.
      - 키를 변경하지 않고 값을 갱신할 때 효율적이다.
    - 색인에서 힙 파일로 다 시 이동하는 일은 읽기 성능에 불이익이 많기 때문에 어떤 상황에서는 색인 안에 색인된 로우를 저장하는데 이를 클러스터드 색인이라고 한다.
    - 클러스터드 색인과 비클러스터드 색인 사이의 절충안을 커버링 색인이나 포괄열이 있는 색인이라 한다.
    - 쓰기 과정에서 오버헤드가 발생하고 애플리케이션 단에서 복제로 인한 불일치를 파악할 수 없기 때문에 트랜잭션 보장을 강화하기 위해 노력해야 한다.
  - **다중 칼럼 색인**
    - 하나의 키만 값에 대응하는 방식은 다중 칼럼에 동시 질의엔 충분하지 않다.
    - 결합 색인
      - 하나의 칼럼에 다른 칼럼을 추가하는 방식으로 하나의 키에 여러 필드를 결합한다.
    - 다차원 색인
      - 지리 공간 데이터에 중요하게 사용된다.
      - 특정 색상 범위의 제품을 검색하기 위해 (빨강, 초록, 파랑) 등을 사용하거나 (날짜, 기온) 등으로 활용된다.
  - **전문 검색과 퍼지 색인**
    - 유사한 키에 대해서는 검색할 수 없으므로 다른 기술이 필요하다.
    - 특정 단어를 검색할 때 해당 단더의 동의어로 질의를 확장한다.
  - **모든 것을 메모리에 보관**
    - 자기 디스크와 SSD를 사용할 때 읽기와 쓰기에서 좋은 성능을 원하면 주의해서 데이터를 디스크에 배치해야 한다.
    - 디스크는 지속성이 있고 램보다 가격이 저렴했지만 램이 저렴해지고 데이터셋이 그다지 크지 않기 때문에 인메모리 데이터베이스가 개발됐다.
    - 지속성을 목표로 하는 인메모리 데이터베이스
      - 특수 하드웨어를 사용
      - 디스크에 변경 사항의 로그를 기록
      - 디스크에 주기적인 스냅숏을 기록
      - 다른 장비에 인메모리 상태를 복제
    - 최근에는 디스크 기반 저장소 엔진도 운영체제가 최근에 사용한 디스크 블록을 메모리에 캐시하기 때문에 충분한 메모리를 가진 경우에는 디스크에서 읽을 필요가 없다.
    - 인메모리 데이터 구조를 디스크에 기록하기 위한 형태로 부호화하는 오버헤드를 피할 수 있어 더 빠를 수 있다.
    - 디스크 기반 색인으로 구현하기 어려운 데이터 모델을 제공한다.
    - 안티 캐싱 접근 방식은 메모리가 충분하지 않을 때 가장 최근에 사용하지 않은 데이터를 메모리에서 디스크로 내보내고 나중에 다시 접근할 때 메모리에 적재하는 방식으로 동작한다.
      - 데이터베이스는 개별 레코드 단위로 작업할 수 있기 때문에 OS보다 효율적으로 메모리를 관리할 수 있다. 
    - 비휘발성 메모리 기술이 널리 채택되면 저장소 엔진 설계의 변경이 필요할 것이다.
##### 트랜잭션 처리나 분석?
- 트랜잭션이 반드시 ACID 속성을 가질 필요는 없다. 트랜잭션 처리는 주기적으로 수행되는 일괄 처리 작업과 달리 클라이언트가 지연 시간이 낮은 읽기와 쓰기를 가능하게 한다는 의미이다.
- 애플리케이션은 사용자 입력을 기반으로 삽입되거나 갱신되는데 대화식이기 때문에 이 접근 패턴을 온라인 트랜잭션 처리(OLTP)라고 한다.

#### 💡 느낀 점
- 가장 단순한 형태의 데이터베이스로부터 시작해 현재의 데이터베이스에 이르기까지 그 과정을 설명해줘서 데이터베이스에 대해서 더 잘 이해할 수 있었다.
- 색인 구조에 대해서 어떻게 생겼는지와 쓰기 성능에 영향을 끼칠 수 있으므로 색인을 생성할 때 주의하라고 하는데 이 부분에 대해서 인덱스 테이블을 새로 생성해야하기 때문에 쓰기 성능에 영향을 끼친다는 근본적인 원리를 알 수 있게 돼서 좋았다.
